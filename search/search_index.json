{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Eric Marquez","text":""},{"location":"#industrial-data-engineering-and-extended-reality","title":"Industrial Data Engineering and Extended Reality","text":""},{"location":"#about-this-portfolio","title":"About this portfolio","text":"<p>This website presents my individual technical contributions to an industrial extended reality project developed during the HT2025 course. The project was a team effort, and the main source code repository is hosted under a teammate\u2019s GitHub account.</p> <p>It focuses on my responsibilities and deliverables, and provides a structured view of my work, supported by screenshots and gifs. A detailed sprint-based log of my individual contributions is available in the Individual contribution log.</p>"},{"location":"#project-context","title":"Project context","text":"<p>The project integrates Siemens PLCs, OPC UA, Node RED, REST APIs, Unity, and Microsoft HoloLens 2 to demonstrate real time industrial data visualization in an XR environment.</p>"},{"location":"#my-role-in-the-project","title":"My role in the project","text":"<p>\u2022 Project leadership and coordination during sprints \u2022 Level 1 connectivity and OPC UA communication validation \u2022 Node RED flow design and implementation \u2022 REST API design for Unity consumption \u2022 Data aggregation into single station based JSON endpoints \u2022 Tests for communication, debugging and deployment on Hololens2</p> <p>My individual contributions are traceable in a dedicated branch of the team repository, referenced in the Version control and collaboration section.</p>"},{"location":"#source-code-repository","title":"Source code repository","text":"<p>The main team repository is hosted here:</p> <p>https://github.com/Sallamhamza/unity-hololens-industrial-data</p>"},{"location":"#quick-links","title":"Quick links","text":"<p>\u2022 XR industrial data pipeline \u2022 Node-RED and OPC UA integration \u2022 Unity and HoloLens integration \u2022 Individual contribution log  \u2022 Version control and collaboration \u2022 Download IPP PDF</p> <p>An Assessment and reflection section is included to satisfy course evaluation requirements.</p>"},{"location":"projects/assessment-and-reflection/","title":"Assessment and reflection","text":"<p>This page reproduces the self-assessment, peer review, and team assessment sections from the Individual Project Portfolio 2 submission, presented verbatim for transparency and course evaluation purposes.</p>"},{"location":"projects/assessment-and-reflection/#self-assessment","title":"Self-assessment","text":"<p>Self-Assessment for IPP part 2 </p> <p>To conclude this second version of the portfolio, I consider that my contribution has been solid. I have established and improved the foundation and the pipeline for acquiring process data, provided support to my teammates, suggested the structure for the project Git repository, participated in the tests for communication, debugging and deployment on Hololens2, and fulfilled the responsibilities of the project leader. As a team, we have successfully overcome several challenges and implemented a pipeline that shows real data in a Unity application deployed on the Hololens 2. </p>"},{"location":"projects/assessment-and-reflection/#reflective-self-assessment","title":"Reflective self-assessment","text":""},{"location":"projects/assessment-and-reflection/#what-went-well-and-why","title":"What went well and why","text":"<p>The backend data integration progressed smoothly because I focused early on stabilizing the data pipeline and defining clear API boundaries. This reduced uncertainty for the rest of the team and enabled parallel development across system components.</p>"},{"location":"projects/assessment-and-reflection/#what-was-challenging-and-why","title":"What was challenging and why","text":"<p>The main challenge was integrating heterogeneous technologies, including PLCs, OPC UA, Node-RED, Unity, and the HoloLens. Ensuring consistent and reliable data flow across these layers required careful debugging and coordination.</p>"},{"location":"projects/assessment-and-reflection/#skills-developed","title":"Skills developed","text":"<p>I developed stronger skills in industrial data integration, REST API design, and system-level debugging. I also improved my ability to communicate technical constraints and design decisions to teammates working on different parts of the system.</p>"},{"location":"projects/assessment-and-reflection/#what-i-would-do-differently-in-the-future","title":"What I would do differently in the future","text":"<p>In future projects, I would define interface contracts and data schemas earlier and introduce automated integration testing to identify issues sooner.</p>"},{"location":"projects/assessment-and-reflection/#what-i-learned-from-scrum-and-teamwork","title":"What I learned from Scrum and teamwork","text":"<p>Working in sprints reinforced the importance of clear task ownership and frequent communication. Scrum practices helped structure progress, while teamwork across disciplines highlighted the value of aligning individual contributions with shared project goals.</p>"},{"location":"projects/assessment-and-reflection/#peer-review-and-group-feedback","title":"Peer review and group feedback","text":"Teammate Feedback (verbatim summary) My reflective response Leon Great ownership of the Node-RED part and pushing the group forward I agree with this feedback. I deliberately took ownership of the Node-RED and data pipeline layer to stabilize industrial data acquisition early. By pushing progress on this backend layer, I aimed to reduce integration risk and ensure that Unity and XR development could proceed without being blocked by data availability. Hamza Organized problem solver, responsible for backend data access and real-time communication, contributed to Unity and UI development I agree with this feedback. I was primarily responsible for backend data access and real-time communication between PLCs, Node-RED, and Unity. While the Unity UI implementation was mainly handled by Hamza, I contributed through integration, testing, and debugging to ensure that backend data was correctly consumed by the application. Jorge Key enabler of the interface between the system and XR deployment, strong experience with PLCs and APIs I agree with this feedback. I focused on designing clear and stable interfaces between the industrial systems and the XR application. I applied prior experience with PLCs and APIs to define appropriate abstraction levels and minimize coupling between the industrial layer and Unity logic."},{"location":"projects/assessment-and-reflection/#personal-assessment-of-the-team","title":"Personal assessment of the team","text":"<p>Leon Pushed and led the image recognition feature of the application and contributed to keeping the project implementation simple but functional.</p> <p>Hamza Hard worker, built from cero the Unity app, explained to the team the details on how the components interact with the scripts and how to deploy to the lenses. Tied together all the pieces into the application.</p> <p>Jorge Good overview of the tasks, keeping track of missing details, presentation slides and playing a key role organizing and hosting the podcast. </p>"},{"location":"projects/assessment-and-reflection/#team-collaboration-and-dissemination","title":"Team collaboration and dissemination","text":"<p>Participating in the project podcast, discussing technical and design aspects of the XR system.</p> <p></p> <p>Project team during podcast recording and technical discussion as part of the XR project.</p>"},{"location":"projects/benefits-limitations-ethics/","title":"Benefits, limitations, system requirements and ethics","text":""},{"location":"projects/benefits-limitations-ethics/#potential-benefits","title":"Potential benefits","text":"<p>\u2022 Enables real-time visualization of industrial process data in XR \u2022 Improves situational awareness for operators and trainees \u2022 Decouples industrial systems from XR applications through stable APIs \u2022 Supports simulation-first development, reducing dependency on live equipment  </p>"},{"location":"projects/benefits-limitations-ethics/#limitations","title":"Limitations","text":"<p>\u2022 System depends on stable network connectivity between PLCs, backend services, and XR devices \u2022 OPC UA address spaces can be complex and vendor-specific \u2022 XR hardware availability and setup introduce deployment overhead \u2022 The solution is a prototype and not production-hardened  </p>"},{"location":"projects/benefits-limitations-ethics/#system-requirements","title":"System requirements","text":""},{"location":"projects/benefits-limitations-ethics/#software","title":"Software","text":"<p>\u2022 Siemens PLCs with OPC UA support \u2022 Node-RED with OPC UA and HTTP nodes \u2022 Unity with MRTK (UWP build support) \u2022 Visual Studio 2022 with ARM64 and UWP components  </p>"},{"location":"projects/benefits-limitations-ethics/#hardware","title":"Hardware","text":"<p>\u2022 Industrial PLC hardware \u2022 Development PC running Windows \u2022 Microsoft HoloLens 2  </p>"},{"location":"projects/benefits-limitations-ethics/#integration","title":"Integration","text":"<p>\u2022 Network access between development computers, PLCs, Node-RED and XR devices \u2022 Firewall configuration allowing REST API communication  </p>"},{"location":"projects/benefits-limitations-ethics/#ethical-considerations","title":"Ethical considerations","text":"<p>This project involves the visualization of industrial process data and interaction with operational systems.</p> <p>Key ethical considerations include:</p> <p>\u2022 Data privacy: Only non-personal, operational machine data was used \u2022 User safety: XR visualization must not distract operators during critical operations \u2022 System reliability: Incorrect or delayed data visualization could lead to unsafe decisions \u2022 Responsibility and accountability: XR systems should support, not replace, human judgment  </p>"},{"location":"projects/benefits-limitations-ethics/#stakeholder-matrix","title":"Stakeholder matrix","text":"Stakeholder Interest Responsibility Ethical concern Operators Use XR for awareness Correct interpretation Safety, distraction Engineers System maintenance Data accuracy Reliability Management Decision support Oversight Misuse of data Organization Deployment Governance Compliance"},{"location":"projects/contribution-log/","title":"Individual contribution log","text":"<p>This page documents my individual contribution to the project in a chronological manner, following the sprint structure, user stories, and tasks defined during the project. The content is derived from the sprint-based organization used in the IPP2 submission.</p> <p>The purpose of this log is to make my work traceable, concrete, and verifiable.</p>"},{"location":"projects/contribution-log/#sprint-1","title":"Sprint 1","text":""},{"location":"projects/contribution-log/#user-story-1-plc-and-node-red-setup","title":"User Story 1 \u2013 PLC and Node-RED setup","text":"<p>Description As a PLC/OPC developer, I want to connect Siemens PLCs to Node-RED via OPC UA so that machine data becomes available for streaming.</p>"},{"location":"projects/contribution-log/#task-1-installing-node-red-and-implementing-opc-ua-nodes","title":"Task 1 \u2013 Installing Node-RED and implementing OPC UA nodes","text":"<p>Description After reading the Node-RED general guide and the Windows installation guide, Node-RED was installed on Windows 11 and additional OPC-related nodes were installed as well.</p> <p>At first, a containerized infrastructure was conceived in which Node-RED and later InfluxDB would be deployed in Docker containers. To this end, Node-RED was also installed on a Linux-based container following the provided instructions.</p> <p>Challenge When using containers, it is advisable to understand how networking is implemented in Docker, especially when using WSL2 on Windows 11 as the host system. Otherwise, the Node-RED instance is not able to \u201csee\u201d the OPC UA simulator or the actual PLC.</p> <p>Regardless of the platform, the outcome is a Node-RED instance running and accessible through http://127.0.0.1:1880/</p>"},{"location":"projects/contribution-log/#tasks-2-and-3-connecting-to-plc-siemens-in-stations-sif-402-and-sif-405","title":"Tasks 2 and 3 \u2013 Connecting to PLC Siemens in stations SIF-402 and SIF-405","text":"<p>Description Data access to the Siemens PLC controlling station SIF-402 was validated using two approaches: the SIF API and direct OPC UA communication. The API was first tested to quickly confirm connectivity and available endpoints by consulting the manufacturer documentation. Initial tests using the checker and inventory endpoints confirmed correct operation and returned station-level inventory data. In parallel, OPC UA communication was validated using an OPC UA browser to understand the PLC address space and verify signal availability before integration with Node-RED.</p> <p>Challenge Navigating the OPC UA object tree was initially non-intuitive, and relevant signals were not immediately obvious. Understanding the PLC address structure required careful inspection of the object hierarchy and cross-referencing manufacturer documentation and signal lists.</p>"},{"location":"projects/contribution-log/#task-4-connecting-to-plc-siemens-in-station-sif-405-via-opc-ua-in-node-red","title":"Task 4 \u2013 Connecting to PLC Siemens in station SIF-405 via OPC UA in node-red","text":"<p>Description To access the PLC data available trough the OPC UA server running on each PLC, we must use the OPC UA client node in node-red, in this case the \u201cRunningTime\u201d signal was selected arbitrarily to run this test, and all the metadata required was extracted from the OPC UA browser.</p> <p>Challenge Using node-red for the first time might be overwhelming, therefore I advise checking these videos from node-red academy which are perfect for understanding the basics as well as the intermediate features.</p> <p>Coding in node-red is done in JavaScript, in principle is not required to know the language, especially if using assistance from generative AI agents, however understanding programming logic is definitively a skill that comes handy here to process and transform the raw signals into a structured format that can later be processed by the Unity application.</p>"},{"location":"projects/contribution-log/#sprint-2","title":"Sprint 2","text":""},{"location":"projects/contribution-log/#user-story-accessing-plc-data-through-opc-ua","title":"User Story \u2013 Accessing PLC data through OPC UA","text":"<p>Description As a PLC/OPC developer, I want to access PLC data through OPC UA so that real-time values can be retrieved and processed.</p>"},{"location":"projects/contribution-log/#task-connecting-node-red-to-the-opc-ua-simulator","title":"Task \u2013 Connecting Node-RED to the OPC UA simulator","text":"<p>Description OPC UA client nodes were configured in Node-RED to connect to the OPC UA simulator. Relevant variables were selected and tested to confirm correct data acquisition.</p> <p>Challenge Browsing large OPC UA address spaces and identifying relevant variables required careful inspection and validation.</p>"},{"location":"projects/contribution-log/#sprint-3","title":"Sprint 3","text":""},{"location":"projects/contribution-log/#user-story-exposing-plc-data-to-external-applications","title":"User Story \u2013 Exposing PLC data to external applications","text":"<p>Description As an application developer, I want to expose PLC data through an API so that it can be consumed by external applications such as Unity.</p>"},{"location":"projects/contribution-log/#task-creating-rest-endpoints-in-node-red","title":"Task \u2013 Creating REST endpoints in Node-RED","text":"<p>Description HTTP endpoints were created in Node-RED to expose PLC data in JSON format. These endpoints were tested locally to verify correct responses.</p> <p>Challenge Exposing raw PLC variables resulted in multiple API calls and increased complexity on the client side.</p>"},{"location":"projects/contribution-log/#sprints-4-and-5","title":"Sprints 4 and 5","text":""},{"location":"projects/contribution-log/#user-story-reformat-data-from-sif402","title":"User Story \u2013 Reformat data from SIF402","text":"<p>Description The previous sprint served as a test for extracting, processing, and displaying data from SIF402. However, after running tests in Unity, it was concluded that the data needed to be reformatted to allow retrieval through a single API call.</p>"},{"location":"projects/contribution-log/#task-reformat-data-from-sif402","title":"Task \u2013 Reformat data from SIF402","text":"<p>Description The Node-RED logic was updated to aggregate multiple variables from SIF402 into a single structured JSON object representing the station state.</p> <p>Challenge Ensuring that all values were coherent at the time of the API response required careful handling of data updates.</p>"},{"location":"projects/contribution-log/#user-story-support-xr-integration-and-deployment","title":"User Story \u2013 Support XR integration and deployment","text":"<p>Description As a project team member, I want to support XR integration and deployment so that the application can be validated on HoloLens 2.</p>"},{"location":"projects/contribution-log/#task-integration-testing-and-deployment-support","title":"Task \u2013 Integration testing and deployment support","text":"<p>Description Integration testing was performed between Node-RED and the Unity application. Deployment and runtime behavior were tested on Microsoft HoloLens 2.</p> <p>Challenge Network configuration and connectivity between the XR device and backend services required additional validation and troubleshooting.</p>"},{"location":"projects/node-red-opcua/","title":"Node RED and OPC UA integration","text":""},{"location":"projects/node-red-opcua/#scope-of-contribution","title":"Scope of contribution","text":"<p>This page documents my primary technical contribution to the project: establishing reliable industrial connectivity and transforming raw PLC signals into structured REST APIs consumable by Unity.</p> <p>My responsibilities covered signal discovery, Node RED flow design, REST API implementation, and station level data aggregation for SIF 402 and SIF 405.</p>"},{"location":"projects/node-red-opcua/#connectivity-validation-using-the-sif-api","title":"Connectivity validation using the SIF API","text":"<p>Before implementing OPC UA flows in Node RED, connectivity to the SIF system was validated using the SIF API checker endpoint. This provided a fast confirmation that the system was reachable and operational.</p> <p></p> <p>Figure 2 \u2013 Response obtained from the GET request to the checker endpoint. Success true confirms that the API is working</p>"},{"location":"projects/node-red-opcua/#node-red-environment-setup","title":"Node RED environment setup","text":"<p>Node RED was installed and configured with OPC UA client nodes to enable communication with Siemens PLCs.</p> <p></p> <p>Figure 1 \u2013 Initial Node RED setup showing OPC UA nodes available</p> <p>This setup was tested both on Windows and in containerized environments. Early tests highlighted networking considerations when using Docker with WSL2, particularly for OPC UA communication.</p>"},{"location":"projects/node-red-opcua/#opc-ua-signal-discovery","title":"OPC UA signal discovery","text":"<p>Before implementing Node RED flows, PLC communication was validated using an OPC UA browser to inspect available signals, browse paths, and data types.</p> <p>SIF 402 discovery example:</p> <p></p> <p>Figure 4 \u2013 OPC UA browser view showing available signals for station SIF 402</p> <p>SIF 405 discovery example:</p> <p></p> <p>Figure 19 \u2013 OPC UA browser view showing feeder related signals for station SIF 405</p>"},{"location":"projects/node-red-opcua/#reading-plc-data-via-opc-ua-in-node-red","title":"Reading PLC data via OPC UA in Node RED","text":"<p>Initial Node RED flows focused on reading a single PLC signal to validate connectivity and data integrity.</p> <p></p> <p>Figure 6 \u2013 Node RED flow reading a single PLC signal through OPC UA</p> <p>Once validated, the flow was extended to read multiple signals in parallel.</p> <p></p> <p>Figure 7 \u2013 Node RED flow scaled to read multiple PLC signals</p>"},{"location":"projects/node-red-opcua/#rest-api-implementation","title":"REST API implementation","text":"<p>To expose PLC data to the Unity application, REST endpoints were implemented using Node RED HTTP In and HTTP Out nodes.</p> <p></p> <p>Figure 8 \u2013 Implementation of a REST API endpoint returning the latest PLC data</p> <p>Flow context was used inside a function node to retain and then return, the latest snapshot of each signal, ensuring that API calls returned a consistent state.</p> Store latest valueReturn latest value <pre><code>flow.set(\"blue_lastSignal\", msg.payload);\nreturn msg;\n</code></pre> <pre><code>const data = flow.get(\"blue_lastSignal\");\nif (!data) {\nmsg.payload = { error: \"No data available yet\" };\nmsg.statusCode = 503;\nreturn msg;\n}\n\nmsg.payload = data;\nmsg.headers = { \"Content-Type\": \"application/json\" };\nreturn msg;\n</code></pre> <p>This REST endpoint returns the latest snapshot of the PLC value in JSON format.</p>"},{"location":"projects/node-red-opcua/#station-level-data-aggregation-for-sif-402","title":"Station level data aggregation for SIF 402","text":"<p>Multiple SIF 402 signals were aggregated into a single JSON object to minimize API calls from Unity. The packed payload included operational signals and hopper state.</p> <p></p> <p>Figure 15 \u2013 Node RED flow aggregating operational and hopper data for station SIF 402</p> <p>The latest raw data from the PLC is captured and transformed into a JSON format through the following code.</p> Extracts OPC UA browser nameLoads latest valuesUpdates new valuesSaves values in flow context <pre><code>let browseName = msg.topic?.browseName;\nlet value = msg.payload;\n</code></pre> <pre><code>let state = flow.get(\"402_state\") || {\nstation: {\n    id: \"SIF-402\",\n    status: \"Unknown\",\n    recipe: \"StandardMix_v2.3\",\n    timestamp: \"\",\n    runningTime: 0,\n    current: 0,\n    hopper1: {\n        present: true,\n        minPellets: true\n    },\n    hopper2: {\n        present: true,\n        minPellets: true\n    },\n    hopper3: {\n        present: true,\n        minPellets: true\n    }\n},\nalarms: []\n};\n</code></pre> <pre><code>switch (browseName) {\n\ncase \"RunningTime\":\n    state.station.runningTime = value;\n    break;\n\ncase \"AlarmBit\":\n    if (value === true) {\n        state.station.status = \"Alarm\";\n        state.alarms = [\n            {\n                id: \"station_alarm\",\n                severity: \"warning\",\n                message: \"Station is in Alarm !\",\n                timestamp: new Date().toISOString()\n            }\n        ];\n    } else {\n        state.station.status = \"Running\";\n        state.alarms = [\n            {\n                id: \"station_alarm\",\n                severity: \"info\",\n                message: \"Station has none alarms\",\n                timestamp: new Date().toISOString()\n            }\n        ];\n    }\n    break;\n\ncase \"Current\":\n    state.station.current = value;\n    break;\n\ncase \"Hopper1_present\":\n    state.station.hopper1.present = value;\n    break;\n\ncase \"Hopper1_Min_pellets\":\n    state.station.hopper1.minPellets = value;\n    break;\n\ncase \"Hopper2_present\":\n    state.station.hopper2.present = value;\n    break;\n\ncase \"Hopper2_Min_pellets\":\n    state.station.hopper2.minPellets = value;\n    break;\n\ncase \"Hopper3_present\":\n    state.station.hopper3.present = value;\n    break;\n\ncase \"Hopper3_Min_pellets\":\n    state.station.hopper3.minPellets = value;\n    break;\n}\n</code></pre> <pre><code>state.station.timestamp = new Date().toISOString();\n\nflow.set(\"402_state\", state);\n\nmsg.payload = state;\nreturn msg;\n</code></pre> <p>The resulting API response exposed all relevant station data in a single request.</p> <p></p> <p>Figure 16 \u2013 REST API response containing aggregated station data for SIF 402</p>"},{"location":"projects/node-red-opcua/#data-identification-and-extraction-for-sif-405-feeders","title":"Data identification and extraction for SIF 405 feeders","text":"<p>For SIF 405, the first step was to identify variables related to the number and type of caps in each feeder by filtering the available signals list.</p> <p></p> <p>Figure 18 \u2013 List of variables filtered for station SIF 405</p> <p>A Node RED flow was then implemented to read these signals via OPC UA and expose them through a REST endpoint, while also including a simulation path for development and testing.</p> <p></p> <p>Figure 20 \u2013 Node RED flow to extract SIF 405 feeder data. The upper section reads PLC data and the lower section supports simulation</p> <p>Data is extracted, validated and then transformed into a JSON format through the following set of code, if simulation mode is enabled it returns mock up values.</p> Extracts OPC UA data Function nodeUpdates valuesBuilds JSON response for both feeders <pre><code>// Normalize key from browseName\nlet keyObj = msg.topic || {};\nlet key = \"\";\n\nif (typeof keyObj === \"object\") {\n    key = keyObj.browseName || keyObj.nodeId || JSON.stringify(keyObj);\n} else {\n    key = String(keyObj);\n}\n\nconst val = msg.payload;\n\n// Ignore weird/unexpected messages\nif (val === undefined || val === null) return null;\n\n// Helper: store real PLC values unless simulation is active\nfunction storeReal(name, value) {\n    const simFlag = flow.get(name + \"_sim\");\n    if (simFlag &amp;&amp; simFlag.active) return;     // simulation active \u2192 ignore PLC\n    flow.set(name, { value: value, simulated: false });\n}\n\n// Route based on browseName\nif (key === \"Feeder1Cap\") storeReal(\"feeder1_cap\", val);\nif (key === \"Feeder1Type\") storeReal(\"feeder1_type\", val);\nif (key === \"Feeder2Cap\") storeReal(\"feeder2_cap\", val);\nif (key === \"Feeder2Type\") storeReal(\"feeder2_type\", val);\n\nreturn null;\n</code></pre> <pre><code>return {\nfeeder1_cap: flow.get(\"feeder1_cap\"),\nfeeder1_cap_sim: flow.get(\"feeder1_cap_sim\"),\nfeeder1_type: flow.get(\"feeder1_type\"),\nfeeder1_type_sim: flow.get(\"feeder1_type_sim\"),\nfeeder2_cap: flow.get(\"feeder2_cap\"),\nfeeder2_cap_sim: flow.get(\"feeder2_cap_sim\"),\nfeeder2_type: flow.get(\"feeder2_type\"),\nfeeder2_type_sim: flow.get(\"feeder2_type_sim\")\n};\n</code></pre> <pre><code>const f1c = flow.get('feeder1_cap');\nconst f1t = flow.get('feeder1_type');\nconst f2c = flow.get('feeder2_cap');\nconst f2t = flow.get('feeder2_type');\n\n// fallback defaults if missing\nfunction safe(val) {\n    return val ? val : {value:0, simulated:true};\n}\n\nconst feeder1 = {\n    feeder: 1,\n    caps: safe(f1c).value,\n    type: safe(f1t).value,\n    simulated: safe(f1c).simulated || safe(f1t).simulated\n};\n\nconst feeder2 = {\n    feeder: 2,\n    caps: safe(f2c).value,\n    type: safe(f2t).value,\n    simulated: safe(f2c).simulated || safe(f2t).simulated\n};\n\nmsg.payload = {\n    feeders: [ feeder1, feeder2 ]\n};\n\nreturn msg;\n</code></pre> <p>The resulting feeder endpoint response is shown here:</p> <p></p> <p>Figure 21 \u2013 REST API response for SIF 405 feeders data</p>"},{"location":"projects/node-red-opcua/#reuse-of-operational-signals-for-sif-405","title":"Reuse of operational signals for SIF 405","text":"<p>The operational signals already implemented for SIF 402, running time, current, and alarm state, were replicated for SIF 405 by reusing the same logic and changing the PLC endpoint, while removing hopper specific signals.</p> <p></p> <p>Figure 23 \u2013 Node RED flow implemented to get operational data from SIF 405 using the same structure as for SIF 402</p> <p>The code is reused and slightly adapted as well.</p> Extracts OPC UA browser nameLoads latest valuesUpdates new valuesSaves values in flow context <pre><code>let browseName = msg.topic?.browseName;\nlet value = msg.payload;\n</code></pre> <pre><code>let state = flow.get(\"405_state\") || {\nstation: {\n    id: \"SIF-405\",\n    status: \"Unknown\",\n    recipe: \"StandardMix_v2.3\",\n    timestamp: \"\",\n    runningTime: 0,\n    current: 0\n},\nalarms: []\n};\n</code></pre> <pre><code>switch (browseName) {\n\ncase \"RunningTime\":\n    state.station.runningTime = value;\n    break;\n\ncase \"AlarmBit\":\n    if (value === true) {\n        state.station.status = \"Alarm\";\n        state.alarms = [\n            {\n                id: \"station_alarm\",\n                severity: \"warning\",\n                message: \"Station is in Alarm !\",\n                timestamp: new Date().toISOString()\n            }\n        ];\n    } else {\n        state.station.status = \"Running\";\n        state.alarms = [\n            {\n                id: \"station_alarm\",\n                severity: \"info\",\n                message: \"Station has none alarms\",\n                timestamp: new Date().toISOString()\n            }\n        ];\n    }\n    break;\n\ncase \"Current\":\n    state.station.current = value;\n    break;    \n}\n</code></pre> <pre><code>state.station.timestamp = new Date().toISOString();\n\nflow.set(\"405_state\", state);\n\nmsg.payload = state;\nreturn msg;\n</code></pre>"},{"location":"projects/node-red-opcua/#outcome","title":"Outcome","text":"<p>The Node RED and OPC UA layer achieved:</p> <p>\u2022 Stable PLC communication for SIF 402 and SIF 405 \u2022 Clear separation between industrial and application layers \u2022 Station level data aggregation to reduce Unity API calls \u2022 REST APIs suitable for XR consumption \u2022 Reusable flow patterns across stations</p>"},{"location":"projects/node-red-opcua/#engineering-challenges-and-lessons-learned","title":"Engineering challenges and lessons learned","text":"<p>\u2022 OPC UA discovery was non-trivial due to deeply nested address spaces and inconsistent signal naming \u2022 Early validation with an OPC UA browser was essential to avoid incorrect node configuration \u2022 Containerized Node-RED setups introduced networking issues under WSL2, reinforcing the need to understand host\u2013container communication \u2022 Aggregating signals into station-level JSON objects significantly reduced API complexity and coupling with Unity \u2022 Flow context management was critical to ensure REST endpoints returned consistent snapshots rather than transient values</p>"},{"location":"projects/unity-hololens/","title":"Unity and HoloLens integration","text":""},{"location":"projects/unity-hololens/#scope-of-contribution","title":"Scope of contribution","text":"<p>The Unity application and XR interaction logic were developed collaboratively as a team effort. My contribution focused on data integration, ensuring that industrial data exposed through Node-RED REST APIs could be reliably consumed, tested, and visualized in Unity and Microsoft HoloLens 2.</p> <p>This page documents that integration perspective.</p>"},{"location":"projects/unity-hololens/#data-consumption-in-unity","title":"Data consumption in Unity","text":"<p>Unity scripts were implemented to fetch station-level data from the REST APIs and deserialize the returned JSON into application data structures.</p> <p></p> <p>Figure 12 \u2013 Example of a C# script used in Unity to request and process station data from the Node-RED REST API</p> <p>From an integration standpoint, the key requirement was that the API responses remained stable and self-contained, allowing Unity to remain decoupled from PLC-specific details.</p>"},{"location":"projects/unity-hololens/#simulation-first-integration-strategy","title":"Simulation-first integration strategy","text":"<p>To enable development and testing without continuous access to the PLC network, simulated OPC UA signals were introduced at the Node-RED layer.</p> <p>This allowed:</p> <p>\u2022 Validation of API structure \u2022 Development of Unity logic independently of PLC availability \u2022 Early verification of XR visualization behavior  </p> <p>The Unity application retrieving simulated data is shown below.</p> <p></p> <p>Figure 13 \u2013 Unity panel displaying simulated station data retrieved through the REST API</p>"},{"location":"projects/unity-hololens/#transition-to-live-plc-data","title":"Transition to live PLC data","text":"<p>Once connectivity and data formatting were validated, simulated signals were replaced with live PLC data without modifying the Unity logic.</p> <p></p> <p>Figure 17 \u2013 Unity application displaying live operational data from station SIF402</p> <p>This confirmed that the station-level API abstraction successfully isolated the XR application from changes in the data source.</p>"},{"location":"projects/unity-hololens/#deployment-and-testing-on-hololens-2","title":"Deployment and testing on HoloLens 2","text":"<p>The final system was deployed and tested on Microsoft HoloLens 2. My involvement focused on:</p> <p>\u2022 Verifying network accessibility of REST endpoints \u2022 Assisting with integration debugging \u2022 Validating correct live data visualization on device  </p> <p>A deployed example showing live feeder data is shown here.</p> <p></p> <p>Figure 22 \u2013 HoloLens view showing live feeder counts for station SIF405</p> <p>The application also supported simultaneous visualization of multiple stations.</p> <p></p> <p>Figure 24 \u2013 HoloLens view showing simultaneous visualization of stations SIF402 and SIF405</p> <p></p> <p></p> <p>Testing the XR application with live industrial data on Microsoft HoloLens 2.</p> <p>Live execution of the XR application on Microsoft HoloLens 2, showing real-time industrial data integration and system interaction.</p>"},{"location":"projects/unity-hololens/#outcome","title":"Outcome","text":"<p>From an integration perspective, the Unity and XR layer demonstrated that:</p> <p>\u2022 REST APIs were stable and suitable for XR consumption \u2022 Simulation enabled parallel development and testing \u2022 Unity logic remained decoupled from PLC structure \u2022 Live industrial data could be reliably visualized on HoloLens 2  </p> <p>This validated the end-to-end pipeline from industrial equipment to XR visualization.</p>"},{"location":"projects/unity-hololens/#engineering-challenges-and-lessons-learned","title":"Engineering challenges and lessons learned","text":"<p>\u2022 Direct dependency on live PLC data would have blocked Unity development during early stages \u2022 A simulation-first strategy enabled parallel development and early validation of XR behavior \u2022 Stable and self-contained REST APIs allowed Unity logic to remain unchanged when switching from simulated to live data \u2022 Network accessibility and firewall configuration became practical deployment constraints during HoloLens testing</p>"},{"location":"projects/version-control/","title":"Version control and collaboration","text":""},{"location":"projects/version-control/#context","title":"Context","text":"<p>This project was developed as a team effort involving multiple technical layers, including industrial connectivity, data pipelines, and XR application development. Effective version control was essential to enable parallel work while avoiding conflicts and unnecessary repository growth.</p> <p>My contribution included defining and supporting practical version control practices adapted to the specific tools used in the project.</p>"},{"location":"projects/version-control/#project-repository-structure-and-workflow","title":"Project repository structure and workflow","text":"<p>The project was developed using a single shared GitHub repository that served as the main integration point for all system components, including XR application code, data pipeline logic, and supporting configuration.</p> <p>https://github.com/Sallamhamza/unity-hololens-industrial-data</p> <p>Work was organized using a feature-based branching strategy, where each team member was responsible for implementing and maintaining a specific feature or subsystem in a dedicated branch. This approach allowed parallel development while preserving a clear integration path into the main branch.</p> <p>My individual contributions are traceable in the following branch:</p> <p>https://github.com/Sallamhamza/unity-hololens-industrial-data/tree/feature/p1-data</p> <p>This branch contains the Node-RED integration work, REST API logic, and supporting configuration corresponding to my assigned feature scope.</p>"},{"location":"projects/version-control/#specifics-about-node-red-version-control","title":"Specifics about Node-RED version control","text":"<p>By default, Node-RED does not provide built-in support for version control of flows. To address this limitation, Node-RED Projects mode was enabled.</p> <p>Projects mode allows Node-RED flows to be:</p> <p>\u2022 Stored as structured files \u2022 Tracked using Git \u2022 Versioned and reviewed like conventional source code  </p> <p>The official Node-RED documentation used as reference is linked below:</p> <p>\u2022 Node-RED Projects documentation   https://nodered.org/docs/user-guide/projects/  </p> <p>Enabling Projects mode was a key step to treat Node-RED flows as maintainable engineering artifacts rather than ad-hoc configurations.</p>"},{"location":"projects/version-control/#unity-specific-version-control-considerations","title":"Unity-specific version control considerations","text":"<p>The Unity user interface and XR interaction cleanup were developed by another team member in a separate feature branch:</p> <p>https://github.com/Sallamhamza/unity-hololens-industrial-data/tree/feature/p3-ui-clean</p> <p>The Unity component required additional version control considerations due to the large number of generated and platform-specific files produced by Unity.</p> <p>To address this, the team followed an established Unity version control workflow, including:</p> <p>\u2022 Use of an appropriate <code>.gitignore</code> for Unity projects \u2022 Versioning only source assets and configuration files \u2022 Excluding generated, cached, and platform-specific artifacts  </p> <p>This procedure is summarized in the reference material linked below:</p> <p>\u2022 Unity version control procedure (video reference used by the team)   https://www.youtube.com/watch?v=dKPdNzETQr8  </p> <p>This ensured that Unity development could proceed in parallel without degrading repository quality.</p>"},{"location":"projects/version-control/#supporting-documentation","title":"Supporting documentation","text":"<p>In addition to the public documentation above, internal project documentation was used to coordinate collaboration and clarify responsibilities across the team.</p> <p>Relevant reference documents include:</p> <p>\u2022 Individual Project Portfolio (academic submission) \u2022 Manufacturer documentation for PLC connectivity and APIs  </p> <p>These documents provided traceability between design decisions, implementation choices, and final outcomes.</p>"},{"location":"projects/version-control/#collaboration-practices","title":"Collaboration practices","text":"<p>Version control practices were aligned with the collaborative nature of the project:</p> <p>\u2022 Clear separation of responsibilities across system layers \u2022 Regular synchronization of changes through GitHub \u2022 Shared understanding of which components were owned individually versus collaboratively  </p> <p>Sprint planning and task coordination were managed using a shared Taiga board, which was used to organize user stories, tasks, and sprint progress throughout the project.</p> <p>https://tree.taiga.io/project/xrteacher-xr2025-g2/timeline</p> <p>These practices reduced integration friction and supported steady progress across sprints.</p>"},{"location":"projects/version-control/#outcome","title":"Outcome","text":"<p>The adopted version control approach enabled:</p> <p>\u2022 Parallel development across Unity and data pipeline layers \u2022 Reduced risk of accidental overwrites or data loss \u2022 Clear traceability of changes in both code and configuration \u2022 A repository structure suitable for future extension and maintenance  </p> <p>This experience reinforced the importance of adapting version control strategies to the specific characteristics of each tool in the technology stack.</p>"},{"location":"projects/xr-industrial-data/","title":"XR industrial data pipeline","text":""},{"location":"projects/xr-industrial-data/#project-context","title":"Project context","text":"<p>This project demonstrates an end-to-end industrial data pipeline where live signals from Siemens PLCs are acquired, processed, and visualized in an extended reality application running on Microsoft HoloLens 2.</p> <p>The work was developed as a team project within the HT2025 course. This page focuses on the overall system architecture and on my individual contributions to the industrial data pipeline enabling the XR application.</p>"},{"location":"projects/xr-industrial-data/#system-overview","title":"System overview","text":"<p>The implemented system consists of the following layers:</p> <p>\u2022 Siemens PLCs providing operational and inventory data \u2022 OPC UA for industrial communication \u2022 Node-RED as an intermediate processing and API layer \u2022 Unity as the application logic layer \u2022 Microsoft HoloLens 2 as the visualization device  </p> <p>The architecture was designed to keep a clear separation between industrial systems and the XR application, enabling testing, simulation, and reuse.</p>"},{"location":"projects/xr-industrial-data/#my-role-in-the-pipeline","title":"My role in the pipeline","text":"<p>My responsibilities focused on the industrial and data engineering layers of the system:</p> <p>\u2022 Level 1 connectivity validation \u2022 OPC UA signal discovery and testing \u2022 Node-RED flow design and implementation \u2022 REST API design for Unity consumption \u2022 Aggregation of station-level data \u2022 Support during integration and XR deployment testing  </p>"},{"location":"projects/xr-industrial-data/#station-level-data-abstraction","title":"Station-level data abstraction","text":"<p>A key design decision was to expose station-level APIs rather than raw signal-level endpoints.</p> <p>For station SIF402, operational signals and hopper states were aggregated into a single JSON object.</p> <p></p> <p>Figure 15 \u2013 Node-RED flow aggregating operational and hopper data for station SIF402</p> <p>The resulting API response exposed all relevant station information in a single request.</p> <p></p> <p>Figure 16 \u2013 REST API response containing aggregated station data for SIF402</p> <p>This abstraction significantly simplified the XR application logic and reduced coupling between Unity and the PLC structure.</p>"},{"location":"projects/xr-industrial-data/#multi-station-support","title":"Multi-station support","text":"<p>The same architectural pattern was applied to additional stations.</p> <p>For station SIF405, feeder-related data was extracted and exposed through a dedicated REST endpoint while reusing the same structural principles.</p> <p></p> <p>Figure 20 \u2013 Node-RED flow extracting feeder data for station SIF405, including simulation support</p> <p>This validated that the pipeline could scale to multiple stations without redesign.</p>"},{"location":"projects/xr-industrial-data/#xr-visualization-and-verification","title":"XR visualization and verification","text":"<p>Before connecting to live PLC data, simulated signals were used to verify the XR application behavior.</p> <p></p> <p>Figure 13 \u2013 Unity panel displaying simulated station data retrieved through the REST API</p> <p>Once connectivity was validated, simulated signals were replaced with live PLC data.</p> <p></p> <p>Figure 17 \u2013 Unity application displaying live operational data from station SIF402</p>"},{"location":"projects/xr-industrial-data/#hololens-2-deployment-results","title":"HoloLens 2 deployment results","text":"<p>The final system was deployed and tested on Microsoft HoloLens 2, visualizing live industrial data in an XR environment.</p> <p></p> <p>Figure 22 \u2013 HoloLens view showing live feeder counts for station SIF405</p> <p>The application also supported simultaneous visualization of multiple stations.</p> <p></p> <p>Figure 24 \u2013 HoloLens view showing simultaneous visualization of SIF402 and SIF405</p>"},{"location":"projects/xr-industrial-data/#outcome","title":"Outcome","text":"<p>The implemented XR industrial data pipeline demonstrated:</p> <p>\u2022 Stable acquisition of live PLC data \u2022 Clear separation between industrial and XR layers \u2022 Station-level data abstraction suitable for XR \u2022 Scalability to multiple stations \u2022 Successful deployment and testing on HoloLens 2  </p> <p>This page captures the system-level perspective of the project, while detailed implementation aspects are documented in the corresponding technical pages.</p>"},{"location":"projects/xr-industrial-data/#engineering-challenges-and-lessons-learned","title":"Engineering challenges and lessons learned","text":"<p>\u2022 Exposing raw PLC signals directly to XR applications creates tight coupling and poor scalability \u2022 Introducing a station-level abstraction simplified the XR logic and enabled multi-station support \u2022 Simulation paths were necessary to decouple development from PLC availability \u2022 Designing the pipeline with clear layer separation made it easier to extend the system to additional stations without redesign</p>"}]}